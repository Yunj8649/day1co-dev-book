# 예시 - TIL (2023.05.10)

### DAY 1

🔖 오늘 읽은 범위 : 
2장 타입스크립트의 타입 시스템 - 아이템9: 타입 단언보다는 타입 선언을 사용하기
2장 타입스크립트의 타입 시스템 - 아이템 10: 객체 래퍼 타입 피하기
2장 타입스크립트의 타입 시스템 - 아이템 11: 잉여 속성 체크의 한계 인지하기

---
<br/>

😃 **책에서 기억하고 싶은 내용을 써보세요.**

- `const alice:Person = { name: 'Alice' };` > 변수에 '타입 선언'을 붙여서 그 값이 선언된 타입임을 명시합니다. (p.53)
- `const bob = { name: 'Bob' } as Person;` > '타입 단언'을 수행합니다. 그러면 타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주합니다. (p.53) 
- 타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사합니다. (p.53)
- 타입 선언문에서는 잉여 속성 체크가 동작했지만, 단언문에서는 적용되지 않습니다. (p.54)
- 변수의 접두사로 쓰인 !는 boolean의 부정문입니다. 그러나 접미사로 쓰인 !는 그 값이 null이 아니라는 단언문으로 해석됩니다. (p.56) 
``` ts
const elNull = document.getElementById('foo') // 타입은 HTMLElement | null
const el = document.getElementById('foo') // 타입은 HTMLElement
```
- 모든 타입은 unknown의 서브타입이기 때문에 unknown이 포함된 단언문은 항상 동작합니다. `const el = document.body as unknown as Person;` (p.56) 
- string '기본형'에는 메서드가 없지만, 자바스크립트에는 메서드를 가지는 String '객체'타입이 정의되어 있습니다. (p.57)
- string 기본형에 charAt 같은 메서드를 사용할 때, 자바스크립트는 기본형을 String 객체로 래핑(wrap)하고, 메서드를 호출하고, 마지막에 래핑한 객체를 버립니다. (p.57) 
- string은 String에 할당할 수 있지만 String은 string에 할당할 수 없습니다. (p.60)
- 타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립트는 해당 타입의 속성이 있는지, 그리고 '그 외의 속성은 없는지' 확인합니다. (p.61)
- 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입스크립트 타입 시스템에 대한 개념을 정확히 잡을 수 있습니다. 
- 잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있습니다. 
- 잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름의 오타같은 실수를 잡는 데 효과적인 방법입니다. 선택적 필드를 포함 타입에 특히 유용한 반면, 적용 범위도 매우 제한적이며 오직 객체 리터럴에만 적용됩니다. 



<br/>

🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

- 몽키-패치란? 
    - 런타임에 프로그램의 어떤 기능을 수정해서 사용하는 기법을 의미합니다. 
    (객체의 메서드를 선언시점이 아닌 사용시점에 확장하는 것)
    자바스크립트에서는 주로 프로토타입을 변경하는 것이 해당됩니다.
- 몽키-패치의 어원
    - 어원이 특이하다고 하는데 원래는 게릴라패치였다고 합니다. 게릴라란 집단에 속하지 않고 개별적인 행위를 하는 사람 또는 단체라는 의미로 그냥 개인플레이라고 생각하시면 됩니다. 게릴라패치 이름 그대로 특정 기능을 위해 개별적인 행위를 해서 이러한 이름이 붙여졌을 것이라 생각했습니다.
    게릴라패치가 몽키패치가 된 건 발음의 유사성에 있습니다.</br>
    게릴라(Guerrilla) -> 고릴라(Gorilla) -> 원숭이(Monkey)
    게릴라 패치에서 발음의 유사한 고릴라패치로 변했는데 고릴라 패치라고 하면 너무 크고 거대한 패치라고 들리는 문제점이 있었다고 합니다. 실은 런타임에서 돌아가는 상대적으로 자그마한 변화였는데 말입니다. 
    그래서 이번에는 발음의 유사성보단 종의 유사성 + 귀여움으로 인해 원숭이로 바뀌게 되었습니다.


<br/>

🥰 **요약**
- 타입 단언(as Type)보다 타입 선언(: Type)을 사용해야 합니다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 합니다.
- 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문과 null 아님 단언문을 사용하면 됩니다.
- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 합니다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야 합니다. 
- 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 합니다. String 대신 string, Number 대신 number, Boolean 대신 boolean, Symbol 대신 symbol, BigInt 대신 bigint를 사용해야 합니다.
- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됩니다. 
- 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다릅니다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있습니다.
- 잉여 속성 체크에는 한계가 있습니다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 점을 기억해야 합니다. 